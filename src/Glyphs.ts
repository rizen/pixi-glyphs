import * as PIXI from "pixi.js";
import {
  TaggedTextOptions,
  TextStyleSet,
  TextStyleExtended,
  TagWithAttributes,
  AttributesList,
  ImageMap,
  ImageSourceMap,
  IMG_REFERENCE_PROPERTY,
  SegmentToken,
  isSpriteToken,
  TextSegmentToken,
  isTextToken,
  isNotWhitespaceToken,
  isNewlineToken,
  isWhitespaceToken,
  Point,
  ParagraphToken,
  TextDecorationMetrics,
  isSpriteSource,
  isTextureSource,
  DEFAULT_KEY,
  PixiTextTypes,
} from "./types";

import { parseTagsNew, removeTags, EMOJI_TAG } from "./tags";
import {
  combineAllStyles,
  convertUnsupportedAlignment,
  getStyleForTag as getStyleForTagExt,
  mapTagsToStyles,
} from "./style";
import { calculateTokens, getBoundsNested } from "./layout";
import { capitalize } from "./stringUtil";
import { fontSizeStringToNumber } from "./pixiUtils";
import { logWarning as _logWarning } from "./errorMessaging";

import DEFAULT_STYLE from "./defaultStyle";
import DEFAULT_OPTIONS from "./defaultOptions";

// TODO: make customizable
const DEBUG = {
  WORD_STROKE_COLOR: 0xffcccc,
  WORD_FILL_COLOR: 0xeeeeee,
  TEXT_FIELD_STROKE_COLOR: 0xff00ff,
  WHITESPACE_COLOR: 0xcccccc,
  WHITESPACE_STROKE_COLOR: 0xaaaaaa,
  BASELINE_COLOR: 0xffff99,
  LINE_COLOR: 0xffff00,
  OUTLINE_COLOR: 0xffcccc,
  OUTLINE_SHADOW_COLOR: 0x000000,
  TEXT_STYLE: {
    fontFamily: "courier",
    fontSize: 10,
    fill: 0xffffff,
    dropShadow: { color: 0x000000, blur: 2, distance: 2, alpha: 1 },
  },
};

const DEFAULT_STYLE_SET = { default: DEFAULT_STYLE };
Object.freeze(DEFAULT_STYLE_SET);
Object.freeze(DEFAULT_STYLE);

const DEFAULT_DESTROY_OPTIONS = {
  children: true,
  texture: true,
  textureSource: false,
  context: false,
};

export default class Glyphs<
  TextType extends PixiTextTypes = PIXI.Text,
> extends PIXI.Container {
  public static get defaultStyles(): TextStyleSet {
    return DEFAULT_STYLE_SET;
  }
  public static get defaultOptions(): TaggedTextOptions {
    return DEFAULT_OPTIONS;
  }

  /** Settings for the Glyphs component. */
  private _options: TaggedTextOptions;
  public get options(): TaggedTextOptions {
    return this._options;
  }

  private _needsUpdate = true;
  public get needsUpdate(): boolean {
    return this._needsUpdate;
  }
  private _needsDraw = true;
  public get needsDraw(): boolean {
    return this._needsDraw;
  }

  private _tokens: ParagraphToken = [];
  /**
   * Tokens representing parsed out and styled tagged text. This is generated by update.
   * They contain all the information needed to render the text fields and other children in your component.
   */
  public get tokens(): ParagraphToken {
    return this._tokens;
  }
  public get tokensFlat(): SegmentToken[] {
    // Use Infinity to flatten all nested levels
    return this._tokens.flat(Infinity) as SegmentToken[];
  }

  private _text = "";
  public get text(): string {
    return this._text;
  }

  /**
   * Alternative implicit setter for text. Always uses default for skipUpdate.
   */
  public set text(text: string) {
    this.setText(text);
  }

  /**
   * Setter for text that allows you to override the default for skipping the update.
   * @param text Text to add to component with (optional) tags.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the text.
   * When true, setText() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setText(text: string, skipUpdate?: boolean): void {
    if (text === this._text && this._needsUpdate === false) {
      return;
    }
    this._text = text;
    this._needsUpdate = true;
    this.updateIfShould(skipUpdate);
  }

  /**
   * Returns the text content with all tags stripped out.
   */
  public get untaggedText(): string {
    return removeTags(this.text);
  }

  private _tagStyles: TextStyleSet = {};
  public get tagStyles(): TextStyleSet {
    return this._tagStyles;
  }

  /**
   * Alternative implicit setter for tagStyles. Always uses default for skipUpdate.
   */
  public set tagStyles(styles: TextStyleSet) {
    this.setTagStyles(styles);
  }

  /**
   * Setter for tagStyles.
   * @param styles Object with strings for keys representing tag names, mapped to style objects.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, setTagStyles() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setTagStyles(styles: TextStyleSet, skipUpdate?: boolean): void {
    Object.entries(styles).forEach(([tag, style]) =>
      this.setStyleForTag(tag, style, true)
    );
    // TODO: add a way to test for identical styles to prevent unnecessary updates.
    this._needsUpdate = true;
    this.updateIfShould(skipUpdate);
  }

  public getStyleForTag(
    tag: string,
    attributes: AttributesList = {}
  ): TextStyleExtended | undefined {
    return getStyleForTagExt(tag, this.tagStyles, attributes);
  }

  public getStyleForTags(tags: TagWithAttributes[]): TextStyleExtended {
    const styles = tags.map(({ tagName, attributes }) =>
      this.getStyleForTag(tagName, attributes)
    );
    return combineAllStyles(styles);
  }

  /**
   * Set a style to be used by a single tag.
   * @param tag Name of the tag to set style for
   * @param styles Style object to assign to the tag.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, setStyleForTag() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setStyleForTag(
    tag: string,
    styles: TextStyleExtended,
    skipUpdate?: boolean
  ): boolean {
    this.tagStyles[tag] = styles;

    // TODO: warn user when trying to set styles on a tag that doesn't support it...
    // e.g. wordWrapWidth on a styel other than default.

    // Override some settings on default styles.
    if (tag === DEFAULT_KEY && this.defaultStyle[IMG_REFERENCE_PROPERTY]) {
      // prevents accidentally setting all text to images.
      this.logWarning(
        `${IMG_REFERENCE_PROPERTY}-on-default`,
        `Style "${IMG_REFERENCE_PROPERTY}" can not be set on the "${DEFAULT_KEY}" style because it will add images to EVERY tag!`
      );
      this.defaultStyle[IMG_REFERENCE_PROPERTY] = undefined;
    }
    // TODO: add a way to test for identical styles to prevent unnecessary updates.
    this._needsUpdate = true;
    this.updateIfShould(skipUpdate);

    return true;
  }
  /**
   * Removes a style associated with a tag. Note, inline attributes are not affected.
   * @param tag Name of the tag to delete the style of.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, removeStylesForTag() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public removeStylesForTag(tag: string, skipUpdate?: boolean): boolean {
    if (tag in this.tagStyles) {
      delete this.tagStyles[tag];

      this._needsUpdate = true;
      this.updateIfShould(skipUpdate);

      return true;
    }
    return false;
  }

  public get defaultStyle(): TextStyleExtended {
    return this.tagStyles?.default;
  }
  /**
   * Alternative implicit setter for defaultStyle. Always uses default for skipUpdate.
   */
  public set defaultStyle(defaultStyles: TextStyleExtended) {
    this.setDefaultStyle(defaultStyles);
  }
  /**
   * Setter for default styles. A shortcut to this.setStyleForTag("default",...)
   * @param styles A style object to use as the default styles for all text in the component.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, setDefaultStyle() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setDefaultStyle(
    defaultStyles: TextStyleExtended,
    skipUpdate?: boolean
  ): void {
    this.setStyleForTag(DEFAULT_KEY, defaultStyles, skipUpdate);
  }

  // References to internal elements.
  private _textFields: TextType[] = [];
  public get textFields(): TextType[] {
    return this._textFields;
  }
  private _sprites: PIXI.Sprite[] = [];
  public get sprites(): PIXI.Sprite[] {
    return this._sprites;
  }
  private _decorations: PIXI.Graphics[] = [];
  public get decorations(): PIXI.Graphics[] {
    return this._decorations;
  }
  private _spriteTemplates: ImageMap = {};
  public get spriteTemplates(): ImageMap {
    return this._spriteTemplates;
  }
  private _debugGraphics: PIXI.Graphics;

  // Containers for children
  private _textContainer: PIXI.Container;
  public get textContainer(): PIXI.Container {
    return this._textContainer;
  }

  private _highlightContainer: PIXI.Container;
  public get highlightContainer(): PIXI.Container {
    return this._highlightContainer;
  }

  private _decorationContainer: PIXI.Container;
  public get decorationContainer(): PIXI.Container {
    return this._decorationContainer;
  }

  private _spriteContainer: PIXI.Container;
  public get spriteContainer(): PIXI.Container {
    return this._spriteContainer;
  }
  private _debugContainer: PIXI.Container;
  public get debugContainer(): PIXI.Container {
    return this._debugContainer;
  }

  private logWarning = (code: string, message: string): void =>
    _logWarning(
      this.options.errorHandler,
      this.options.supressConsole,
      this
    )(code, message);

  constructor(
    text = "",
    tagStyles: TextStyleSet = {},
    options: TaggedTextOptions = {}
  ) {
    super();

    this._textContainer = new PIXI.Container();
    this._spriteContainer = new PIXI.Container();
    this._highlightContainer = new PIXI.Container();
    this._decorationContainer = new PIXI.Container();
    this._debugContainer = new PIXI.Container();
    this._debugGraphics = new PIXI.Graphics();

    this.resetChildren();

    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
    this._options = mergedOptions;

    tagStyles = { default: {}, ...tagStyles };

    if (this.options.wrapEmoji) {
      const userStyles = tagStyles[EMOJI_TAG];
      tagStyles[EMOJI_TAG] = {
        fontFamily: "sans-serif",
        ...userStyles,
      };
    }
    // Merge lineSpacing and paragraphSpacing from options into default style
    const styleOverrides: any = { ...tagStyles.default };
    if (options.lineSpacing !== undefined) {
      styleOverrides.lineSpacing = options.lineSpacing;
    }
    if (options.paragraphSpacing !== undefined) {
      styleOverrides.paragraphSpacing = options.paragraphSpacing;
    }

    const mergedDefaultStyles = { ...DEFAULT_STYLE, ...styleOverrides };
    tagStyles.default = mergedDefaultStyles;
    this.tagStyles = tagStyles;

    if (this.options.imgMap) {
      this.createSpriteTemplatesFromSourceMap(this.options.imgMap);
    }

    this.text = text;
  }

  public destroyImgMap(): void {
    if (this.destroyed) {
      throw new Error(
        "destroyImgMap() was called after this object was already destroyed. You must call destroyImgMap() before destroy() because imgMap is cleared when the object is destroyed."
      );
    }

    this._spriteContainer.destroy({
      children: true,
      texture: true,
      textureSource: true,
    });
  }

  public destroy(options?: boolean | PIXI.DestroyOptions): void {
    let destroyOptions: PIXI.DestroyOptions;
    if (options === undefined || options === true) {
      destroyOptions = {};
    } else if (options === false) {
      destroyOptions = DEFAULT_DESTROY_OPTIONS;
    } else {
      destroyOptions = { ...DEFAULT_DESTROY_OPTIONS, ...options };
    }

    // Do not destroy the sprites in the imgMap.
    this._spriteContainer.destroy(false);

    super.destroy(destroyOptions);

    this._textFields = [];
    this._sprites = [];
    this._decorations = [];
    this._spriteTemplates = {};
    this._tokens = [];
    this._tagStyles = {};
    this._options.imgMap = {};
    this._options.skipUpdates = true;
    this._options.skipDraw = true;
    this._options = {};
  }

  /**
   * Removes all PIXI children from this component's containers.
   * Deletes references to sprites and text fields.
   */
  protected resetChildren() {
    // Add highlight container first so it appears behind everything
    if (this._highlightContainer) {
      // Properly destroy all children to prevent memory leaks
      this._highlightContainer.removeChildren().forEach((child) => child.destroy());
      const removed = this.removeChild(this._highlightContainer);
      if (removed) removed.destroy();
    }
    this._highlightContainer = new PIXI.Container();
    this.addChild(this._highlightContainer);

    if (this._textContainer) {
      // Properly destroy all children to prevent memory leaks
      this._textContainer.removeChildren().forEach((child) => child.destroy());
      const removed = this.removeChild(this._textContainer);
      if (removed) removed.destroy();
    }
    this._textContainer = new PIXI.Container();
    this.addChild(this._textContainer);

    if (this._spriteContainer) {
      // Don't destroy sprites as they may be reused from imgMap
      this._spriteContainer.removeChildren();
      const removed = this.removeChild(this._spriteContainer);
      if (removed) removed.destroy();
    }
    this._spriteContainer = new PIXI.Container();
    this.addChild(this._spriteContainer);

    if (this._decorationContainer) {
      // Properly destroy all children to prevent memory leaks
      this._decorationContainer.removeChildren().forEach((child) => child.destroy());
      const removed = this.removeChild(this._decorationContainer);
      if (removed) removed.destroy();
    }
    this._decorationContainer = new PIXI.Container();
    this.addChild(this._decorationContainer);

    if (this._debugContainer) {
      // Properly destroy all children to prevent memory leaks
      this._debugContainer.removeChildren().forEach((child) => child.destroy());
      const removed = this.removeChild(this._debugContainer);
      if (removed) removed.destroy();
    }
    this._debugContainer = new PIXI.Container();
    this.addChild(this._debugContainer);

    this._textFields = [];
    this._sprites = [];
    this._decorations = [];
  }

  /**
   * Creates associations between string-based keys like "img" and
   * image Sprite objects which are included in the text.
   * @param imgMap
   */
  protected createSpriteTemplatesFromSourceMap(imgMap: ImageSourceMap) {
    this._spriteTemplates = {};

    Object.entries(imgMap).forEach(([key, spriteSource]) => {
      const wrongFormatError = new TypeError(
        `The spriteSource provided for key ${key} was not in a valid format. Please use a Sprite, Texture, BaseTexture, string, HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, or SVGElement`
      );
      const destroyedError = new Error(
        `The spriteSource provided for key ${key} appears to be a Sprite or Texture that has been destroyed or removed from PIXI.TextureCache probably using \`destroy()\` with aggressive options or \`destroyImgMap()\`.`
      );
      let error: Error | null = null;

      let sprite: PIXI.Sprite = new PIXI.Sprite();

      try {
        if (spriteSource instanceof PIXI.Sprite) {
          sprite = spriteSource;
        }
        // if the entry is not a sprite, attempt to load the sprite as if it is a reference to the sprite source (e.g. an Image element, url, or texture).
        else if (isSpriteSource(spriteSource)) {
          const texture = spriteSource instanceof PIXI.Texture ? spriteSource : PIXI.Texture.from(spriteSource);
          sprite = new PIXI.Sprite(texture);
        } else if (isTextureSource(spriteSource)) {
          sprite = new PIXI.Sprite(PIXI.Texture.from(spriteSource));
        } else {
          error = wrongFormatError;
          console.log(error);
        }
      } catch (e) {
        error = e as Error;
        console.log(error);
      }

      if (
        (isSpriteSource(spriteSource) &&
          (spriteSource as PIXI.Texture).source === null) ||
        (sprite !== undefined &&
          (sprite.destroyed || sprite.texture?.source === null))
      ) {
        error = destroyedError;
        console.log(error);
      }

      if (error) {
        throw error;
      }

      // Listen for changes to sprites (e.g. when they load.)
      const texture = sprite.texture;

      const onTextureUpdate = () => {
        this.onImageTextureUpdate(texture);
        texture.source.removeListener("update", onTextureUpdate);
      };

      // In PIXI v8, listen on the source instead of baseTexture
      if (texture.source) {
        texture.source.addListener("update", onTextureUpdate);
      }

      this.spriteTemplates[key] = sprite;

      // create a style for each of these by default.
      const existingStyle = this.getStyleForTag(key) ?? {};
      const style = { [IMG_REFERENCE_PROPERTY]: key, ...existingStyle };
      this.setStyleForTag(key, style);
    });
  }

  private onImageTextureUpdate(_texture: PIXI.Texture): void {
    this._needsUpdate = true;
    this._needsDraw = true;
    this.updateIfShould();
  }

  /**
   * Determines whether to call update based on the parameter and the options set then calls it or sets needsUpdate to true.
   * @param forcedSkipUpdate This is the parameter provided to some functions that allow you to skip the update.
   * It's factored in along with the defaults to figure out what to do.
   */
  private updateIfShould(forcedSkipUpdate?: boolean): boolean {
    if (
      forcedSkipUpdate === false ||
      (forcedSkipUpdate === undefined && this.options.skipUpdates === false)
    ) {
      this.update();
      return true;
    }
    return false;
  }

  /**
   * Calculates styles, positioning, etc. of the text and styles and creates a
   * set of objects that represent where each portion of text and image should
   * be drawn.
   * @param skipDraw *For advanced users* overrides default for redrawing the styles.
   * When true, update() will skip the call to draw() (even if the default is false).
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public update(skipDraw?: boolean): ParagraphToken {
    // Determine default style properties
    const tagStyles = this.tagStyles;
    const { splitStyle, scaleIcons } = this.options;
    const spriteTemplates = this.options.imgMap && this.spriteTemplates;
    // const wordWrapWidth = this.defaultStyle.wordWrap
    //   ? this.defaultStyle.wordWrapWidth
    //   : Number.POSITIVE_INFINITY;
    // const align = this.defaultStyle.align;
    // const lineSpacing = this.defaultStyle.lineSpacing;

    // Pre-process text.
    // Parse tags in the text.
    const tagTokensNew = parseTagsNew(
      this.text,
      Object.keys(this.tagStyles),
      this.options.wrapEmoji,
      this.logWarning
    );
    // Assign styles to each segment.
    const styledTokens = mapTagsToStyles(
      tagTokensNew,
      tagStyles,
      spriteTemplates
    );
    // Measure font for each style
    // Measure each segment
    // Create the text segments, position and add them. (draw)
    const newFinalTokens = calculateTokens(
      styledTokens,
      splitStyle,
      scaleIcons,
      this.options.adjustFontBaseline
    );

    this._tokens = newFinalTokens;
    this._needsDraw = true;

    // Wait one frame to draw so that this doesn't happen multiple times in one frame.
    // if (this.animationRequest) {
    //   window.cancelAnimationFrame(this.animationRequest);
    // }
    // this.animationRequest = window.requestAnimationFrame(

    this.drawIfShould(skipDraw);

    if (this.options.debugConsole) {
      console.log(this.toDebugString());
    }

    this._needsUpdate = false;

    return newFinalTokens;
  }

  /**
   * Determines whether to call draw() based on the parameter and the options set then calls it or sets needsDraw to true.
   * @param forcedSkipDraw This is the parameter provided to some functions that allow you to skip the update.
   * It's factored in along with the defaults to figure out what to do.
   */
  private drawIfShould(forcedSkipDraw?: boolean): boolean {
    if (
      forcedSkipDraw === false ||
      (forcedSkipDraw === undefined && this.options.skipDraw === false)
    ) {
      this.draw();
      return true;
    }

    return false;
  }

  /**
   * Create and position the display objects based on the tokens.
   */
  public draw(): void {
    this.resetChildren();
    if (this.textContainer === null || this.spriteContainer === null || this.highlightContainer === null) {
      throw new Error(
        "Somehow the textContainer, spriteContainer, or highlightContainer is null. This shouldn't be possible. Perhaps you've destroyed this object?"
      );
    }
    const textContainer = this.textContainer;
    const spriteContainer = this.spriteContainer;
    const highlightContainer = this.highlightContainer;

    const { drawWhitespace } = this.options;
    const tokensFlat = this.tokensFlat;


    const tokens = drawWhitespace
      ? tokensFlat
      : // remove any tokens that are purely whitespace unless drawWhitespace is specified
      tokensFlat.filter(isNotWhitespaceToken);

    // Draw highlights first so they appear behind text
    // Group consecutive tokens with the same highlight color
    let i = 0;
    while (i < tokensFlat.length) {
      const token = tokensFlat[i];
      if (isTextToken(token) && token.style.highlightColor !== undefined) {
        // Find all consecutive tokens with the same highlight color
        const highlightColor = token.style.highlightColor;
        let startX = token.bounds.x;
        let minY = token.bounds.y;
        let maxY = token.bounds.y + token.bounds.height;
        let endX = token.bounds.x + token.bounds.width;

        let j = i + 1;
        while (j < tokensFlat.length) {
          const nextToken = tokensFlat[j];
          // Check if next token has the same highlight color and is on the same line
          if (isTextToken(nextToken) &&
              nextToken.style.highlightColor === highlightColor &&
              Math.abs(nextToken.bounds.y - token.bounds.y) < 5) { // Same line check
            endX = nextToken.bounds.x + nextToken.bounds.width;
            minY = Math.min(minY, nextToken.bounds.y);
            maxY = Math.max(maxY, nextToken.bounds.y + nextToken.bounds.height);
            j++;
          } else {
            break;
          }
        }

        // Create a single highlight box for the group
        const highlight = this.createHighlightBox(
          highlightColor,
          startX,
          minY,
          endX - startX,
          maxY - minY
        );
        if (highlight) {
          highlightContainer.addChild(highlight);
        }

        i = j;
      } else {
        i++;
      }
    }

    let drewDecorations = false;
    let displayObject: PIXI.Container;
    let renderedCount = 0;

    tokens.forEach((t, index) => {
      if (isTextToken(t)) {
        displayObject = this.createTextFieldForToken(t as TextSegmentToken);

        textContainer.addChild(displayObject);
        this.textFields.push(displayObject as TextType);
        renderedCount++;

        if (t.textDecorations && t.textDecorations.length > 0) {
          for (const d of t.textDecorations) {
            // Create a copy of the decoration metrics with adjusted bounds for absolute positioning
            // Use t.bounds which contains the actual text position
            const absoluteDecoration = {
              color: d.color,
              bounds: {
                x: d.bounds.x + t.bounds.x,
                y: d.bounds.y + t.bounds.y,
                width: d.bounds.width,
                height: d.bounds.height
              }
            };
            const drawing = this.createDrawingForTextDecoration(absoluteDecoration);
            // In PIXI v8, Text objects cannot have children, so add decorations to the decoration container
            this._decorationContainer.addChild(drawing);
            this._decorations.push(drawing);
          }
          drewDecorations = true;
        }
      }
      if (isSpriteToken(t)) {
        displayObject = t.content as PIXI.Sprite;

        this.sprites.push(displayObject as PIXI.Sprite);
        spriteContainer.addChild(displayObject);
      }

      const { bounds } = t;

      displayObject.x = bounds.x;
      displayObject.y = bounds.y;

      // For icon sprites, push them down relative to their baseline
      if (isSpriteToken(t)) {
        const imgDisplay = t.style['imgDisplay'];
        if (imgDisplay === 'icon') {
          // Push icon down by 0.1em below its baseline position
          let fontSize = t.style.fontSize || 20;
          if (typeof fontSize === 'string') {
            fontSize = parseInt(fontSize.replace('px', ''), 10);
          }
          const iconOffset = fontSize * 0.1;
          displayObject.y = bounds.y + iconOffset;

        }
      }
    });

    if (drawWhitespace === false && drewDecorations) {
      this.logWarning(
        "text-decoration-and-whitespace",
        "Text decorations, such as underlines, will not appear under whitespace unless the `drawWhitespace` option is set to `true`."
      );
    }

    if (this.options.debug) {
      this.drawDebug();
    }
    this._needsDraw = false;
  }

  protected createDrawingForTextDecoration(
    textDecoration: TextDecorationMetrics
  ): PIXI.Graphics {
    const { overdrawDecorations: overdraw = 0 } = this.options;
    const { bounds } = textDecoration;
    let { color } = textDecoration;

    // Early return if no decoration is needed
    if (!bounds || (bounds.width <= 0 && bounds.height <= 0)) {
      return new PIXI.Graphics();
    }

    const drawing = new PIXI.Graphics();

    // Convert color to a number if it's a string
    if (typeof color === "string") {
      if (color.indexOf("#") === 0) {
        color = "0x" + color.substring(1);
        color = parseInt(color, 16) as number;
      } else {
        this.logWarning(
          "invalid-color",
          "Sorry, at this point, only hex colors are supported for textDecorations like underlines. Please use either a hex number like 0x66FF33 or a string like '#66FF33'"
        );
        color = 0x000000; // Default to black if invalid
      }
    }

    // Ensure color is defined (default to black if undefined)
    if (color === undefined || color === null) {
      color = 0x000000;
    }

    // Ensure color is a valid number
    const finalColor = typeof color === 'number' ? color : 0x000000;

    // the min , max here prevents the overdraw from producing a negative width drawing.
    const { y, height } = bounds;
    const midpoint = bounds.x + bounds.width / 2;
    const x = Math.min(bounds.x - overdraw, midpoint);
    const width = Math.max(bounds.width + overdraw * 2, 0);

    // In PIXI v8, use the new Graphics API
    // According to PIXI v8 docs, we should use setFillStyle then rect then fill
    drawing.setFillStyle({ color: finalColor });
    drawing.rect(x, y, width, height);
    drawing.fill();

    return drawing;
  }

  protected createTextField(text: string, style: TextStyleExtended): TextType {
    // In Pixi v8, Text constructor takes an options object
    // Clean up the style for PIXI v8
    const cleanedStyle = { ...style };

    // In PIXI v8, stroke needs to be an object if it exists
    // Convert old format (stroke: color, strokeThickness: number) to new format
    if (cleanedStyle.stroke && typeof cleanedStyle.stroke !== 'object') {
      cleanedStyle.stroke = {
        color: cleanedStyle.stroke,
        width: cleanedStyle.strokeThickness || 0
      } as any;
    }

    // Always delete strokeThickness to prevent PIXI v8 deprecation warnings
    if (cleanedStyle.strokeThickness !== undefined) {
      delete cleanedStyle.strokeThickness;
    }

    const textField = new PIXI.Text({
      text: text,
      style: cleanedStyle as Partial<PIXI.TextStyle>
    });

    return textField as TextType;
  }

  protected createHighlightBox(
    highlightColor: any,
    x: number,
    y: number,
    width: number,
    height: number
  ): PIXI.Graphics | null {
    if (!highlightColor || width <= 0 || height <= 0) {
      return null;
    }

    const highlight = new PIXI.Graphics();
    let color = highlightColor;

    // Convert color to a number if it's a string
    if (typeof color === "string") {
      if (color.indexOf("#") === 0) {
        color = "0x" + color.substring(1);
        color = parseInt(color, 16) as number;
      } else {
        this.logWarning(
          "invalid-highlight-color",
          "Sorry, at this point, only hex colors are supported for highlightColor. Please use either a hex number like 0x66FF33 or a string like '#66FF33'"
        );
        color = 0xFFFF00; // Default to yellow if invalid
      }
    }

    // Draw the highlight box
    highlight.rect(0, 0, width, height)
      .fill({ color: color as number });

    // Position the highlight
    highlight.x = x;
    highlight.y = y;

    return highlight;
  }

  protected createTextFieldForToken(token: TextSegmentToken): TextType {
    const { textTransform = "" } = token.style;

    let text = token.content;
    switch (textTransform.toLowerCase()) {
      case "lowercase":
        text = text.toLowerCase();
        break;
      case "uppercase":
        text = text.toUpperCase();
        break;
      case "capitalize":
        text = capitalize(text);
        break;
      default:
    }

    const alignClassic = convertUnsupportedAlignment(token.style.align);
    const sanitizedStyle = {
      ...token.style,
      align: alignClassic,
    } as TextStyleExtended;

    const textField = this.createTextField(text, sanitizedStyle) as PIXI.Text;

    let { fontScaleWidth = 1.0, fontScaleHeight = 1.0 } = token.style;
    fontScaleWidth =
      isNaN(fontScaleWidth) || fontScaleWidth < 0 ? 0 : fontScaleWidth;
    fontScaleHeight =
      isNaN(fontScaleHeight) || fontScaleHeight < 0 ? 0 : fontScaleHeight;

    let finalScaleWidth = fontScaleWidth;
    let finalScaleHeight = fontScaleHeight;
    const largerScale = Math.max(fontScaleWidth, fontScaleHeight);

    if (largerScale > 1) {
      if (largerScale === fontScaleHeight) {
        finalScaleWidth /= largerScale;
        finalScaleHeight = 1.0;
      } else {
        finalScaleHeight /= largerScale;
        finalScaleWidth = 1.0;
      }

      const fs = textField.style.fontSize ?? 0;
      const fontSizePx =
        (typeof fs === "string" ? fontSizeStringToNumber(fs) : fs) *
        largerScale;

      textField.style.fontSize = fontSizePx;
    }

    textField.scale.set(finalScaleWidth, finalScaleHeight);

    return textField as TextType;
  }

  /**
   * Converts the text properties from this.tokens into a human readable string.
   * This is automatically logged to the console on update when debug option is set to true.
   */
  public toDebugString(): string {
    const lines = this.tokens;
    let s = this.untaggedText + "\n=====\n";
    const nl = "\n    ";
    if (lines !== undefined) {
      s += lines.map((line, lineNumber) =>
        line.map((word, wordNumber) =>
          word
            .map((token, tokenNumber) => {
              let text = "";
              if (isTextToken(token)) {
                if (isNewlineToken(token)) {
                  text = `\\n`;
                } else {
                  text = `"${token.content}"`;
                }
              } else if (isSpriteToken(token)) {
                text = `[Image]`;
              }
              let s = `\n${text}: (${lineNumber}/${wordNumber}/${tokenNumber})`;
              s += `${nl}tags: ${token.tags.length === 0
                ? "<none>"
                : token.tags
                  .split(",")
                  .map((tag) => `<${tag}>`)
                  .join(", ")
                }`;
              s += `${nl}style: ${Object.entries(token.style)
                .map((e) => e.join(":"))
                .join("; ")}`;
              s += `${nl}size: x:${token.bounds.x} y:${token.bounds.y} width:${token.bounds.width
                } height:${token.bounds.height} bottom:${token.bounds.height + token.bounds.y
                } right:${token.bounds.x + token.bounds.width}`;
              s += `${nl}font: fontSize:${token.fontProperties.fontSize} ascent:${token.fontProperties.ascent} descent:${token.fontProperties.descent}`;
              return s;
            })
            .join("\n")
        )
      );
    }
    return s;
  }

  public drawDebug(): void {
    const paragraph = this.tokens;
    this._debugGraphics = new PIXI.Graphics();
    if (this.debugContainer === null) {
      throw new Error(
        "Somehow the debug container is null. This shouldn't be possible. Perhaps you've destroyed this object?"
      );
    }
    const debugContainer = this.debugContainer;

    // Remove and re-add graphics in the correct order to ensure proper layering
    debugContainer.removeChildren();

    // Add main graphics first (bottom layer)
    debugContainer.addChild(this._debugGraphics);
    const g = this._debugGraphics;
    g.clear();

    // Create and add line-height graphics second (on top)
    let lineHeightGraphics = new PIXI.Graphics();
    lineHeightGraphics.label = 'lineHeightGraphics';
    debugContainer.addChild(lineHeightGraphics);
    lineHeightGraphics.clear();

    // Create and add baseline graphics third (topmost layer)
    let baselineGraphics = new PIXI.Graphics();
    baselineGraphics.label = 'baselineGraphics';
    baselineGraphics.visible = true;
    baselineGraphics.alpha = 1;
    debugContainer.addChild(baselineGraphics);
    baselineGraphics.clear();

    // Store baseline data to draw after everything else
    const baselines: Array<{ x: number, baseline: number, width: number }> = [];

    // const { width, height } = this.getBounds();
    // // frame shadow
    // g.lineStyle(2, DEBUG.OUTLINE_SHADOW_COLOR, 0.5);
    // // g.beginFill();
    // g.drawRect(1, 1, width, height);
    // // g.endFill();

    // // frame
    // g.lineStyle(2, DEBUG.OUTLINE_COLOR, 1);
    // // g.beginFill();
    // g.drawRect(0, 0, width - 1, height - 1);
    // // g.endFill();

    function createInfoText(text: string, position: Point): PIXI.Text {
      const info = new PIXI.Text({ text, style: DEBUG.TEXT_STYLE });
      info.x = position.x + 1;
      info.y = position.y + 1;
      return info;
    }

    // Pass lineHeightGraphics to inner scope
    const lineHeightGfx = lineHeightGraphics;

    // for (const line of tokens) {
    for (let lineNumber = 0; lineNumber < paragraph.length; lineNumber++) {
      const line = paragraph[lineNumber];
      const lineBounds = getBoundsNested(line);

      // Calculate the maximum topTrim for this line to apply to debug boxes
      // This matches the logic in layout.ts
      let maxTopTrim = 0;
      for (const word of line) {
        for (const segment of word) {
          const topTrim = segment.style.topTrim ?? 0;
          if (Math.abs(topTrim) > Math.abs(maxTopTrim)) {
            maxTopTrim = topTrim;
          }
        }
      }

      // Calculate the actual tallest effective height in the line after topTrim adjustments
      // This determines the overall line height box
      let tallestEffectiveHeight = 0;
      let tallestEffectiveY = Number.POSITIVE_INFINITY;

      for (const word of line) {
        for (const segment of word) {
          const topTrim = segment.style.topTrim ?? 0;
          let segmentAscent = segment.fontProperties.ascent;
          const segmentDescent = segment.fontProperties.descent;

          // Apply topTrim to this segment's ascent
          if (topTrim !== 0) {
            segmentAscent = Math.max(0, segmentAscent - topTrim);
          }

          const effectiveHeight = segmentAscent + segmentDescent;
          const effectiveY = segment.bounds.y + segment.fontProperties.ascent - segmentAscent;

          if (effectiveHeight > tallestEffectiveHeight) {
            tallestEffectiveHeight = effectiveHeight;
            tallestEffectiveY = effectiveY;
          }
        }
      }

      // Set line box dimensions based on the tallest effective segment
      let lineBoxY = tallestEffectiveY;
      let lineBoxHeight = tallestEffectiveHeight;

      if (this.defaultStyle.wordWrap) {
        const w = (this.defaultStyle.wordWrapWidth ?? this.width) as number;
        // In PIXI v8, use rect with stroke
        g.rect(0, lineBoxY, w, lineBoxHeight)
          .stroke({ width: 0.5, color: DEBUG.LINE_COLOR, alpha: 0.2 });
      }

      for (let wordNumber = 0; wordNumber < line.length; wordNumber++) {
        const word = line[wordNumber];
        for (const segmentToken of word) {
          const isSprite = isSpriteToken(segmentToken);
          const { x, y, width } = segmentToken.bounds;

          // Calculate the actual visual baseline position
          // Key insight: PIXI.Text renders with its y coordinate at the TOP of the text
          // actualBoundingBoxAscent measures from the BASELINE up to the top
          // So: baseline = text.y + ascent
          //
          // BUT the actual visual pixels may not start exactly at text.y
          // We need to find where the baseline actually is relative to text.y
          let baseline: number;
          if (isSprite) {
            baseline = y + segmentToken.bounds.height;
          } else {
            // The ascent is the distance from baseline UP to the top of the character
            // So if y is the top, baseline should be y + ascent
            baseline = y + segmentToken.fontProperties.ascent;

            // However, PIXI may have internal padding or the actual rendered pixels
            // may not start exactly at y. Let's check the actual text height vs metrics
            const actualHeight = segmentToken.bounds.height;
            const metricsHeight = segmentToken.fontProperties.ascent + segmentToken.fontProperties.descent;
            const heightDifference = actualHeight - metricsHeight;

            // If there's padding, adjust the baseline down by that amount
            if (heightDifference > 1) {
              baseline += heightDifference / 2;
            }
          }

          // Calculate proper box dimensions based on ascent and descent
          let boxY = y;
          let boxHeight = segmentToken.bounds.height;

          if (!isSprite) {
            // For text, the box should show from top of ascent to bottom of descent
            let ascent = segmentToken.fontProperties.ascent;
            const descent = segmentToken.fontProperties.descent;

            // Apply THIS SEGMENT'S individual topTrim to the ascent for the debug box
            // This reflects the actual line height adjustment from layout.ts
            const segmentTopTrim = segmentToken.style.topTrim ?? 0;
            if (segmentTopTrim !== 0) {
              ascent = Math.max(0, ascent - segmentTopTrim);
            }

            // The baseline is at y + ascent (as calculated above)
            // So the top should be at baseline - ascent = y
            // And the bottom should be at baseline + descent = y + ascent + descent
            boxY = baseline - ascent;  // Top of ascender
            boxHeight = ascent + descent;  // Full height from ascender to descender
          } else {
            // For sprites, use full height
            boxHeight = segmentToken.bounds.height + segmentToken.fontProperties.descent;
          }

          const strokeColor = (isWhitespaceToken(segmentToken) && this.options.drawWhitespace === false)
            ? DEBUG.WHITESPACE_STROKE_COLOR
            : DEBUG.WORD_STROKE_COLOR;
          const fillColor = (isWhitespaceToken(segmentToken) && this.options.drawWhitespace === false)
            ? DEBUG.WHITESPACE_COLOR
            : DEBUG.WORD_FILL_COLOR;

          if (isNewlineToken(segmentToken)) {
            this.debugContainer.addChild(
              createInfoText("↩︎", { x, y: boxY + 10 })
            );
          } else {
            // Draw line-height box with no fill, only semi-transparent stroke
            g.rect(x, boxY, width, boxHeight)
              .stroke({ width: 0.5, color: DEBUG.LINE_COLOR, alpha: 0.2 });

            // Draw word box with semi-transparent debug color fill
            g.rect(x, y, width, segmentToken.bounds.height)
              .fill({ color: fillColor, alpha: 0.2 })
              .stroke({ width: 0.5, color: strokeColor, alpha: 0.5 });

            // Store baseline data to draw later on top of everything
            baselines.push({ x, baseline, width });
          }

          let info;
          // info = `${token.bounds.width}⨉${token.bounds.height}`;
          if (isTextToken(segmentToken)) {
            // info += ` ${token.tags}`;
            info = `${segmentToken.tags}`;
            this.debugContainer.addChild(createInfoText(info, { x, y: boxY }));
          }
          // this.debugContainer.addChild(createInfoText(info, { x, y }));
        }
      }
    }
    // }

    // Draw all baselines on top of everything else
    // Try different approach for PIXI v8
    if (baselines.length > 0) {
      // Use rect instead of lines for better visibility
      for (const { x, baseline, width } of baselines) {
        // Draw a thin rectangle instead of a line
        baselineGraphics.rect(x, baseline - 1, width, 2)
          .fill({ color: DEBUG.BASELINE_COLOR, alpha: 0.8 });
      }
    }

    // Show the outlines of the actual text fields,
    // not just where the tokens say they should be
    // const fields: PIXI.Text[] = this.textFields;
    // for (const text of fields) {
    //   g.lineStyle(1, DEBUG.TEXT_FIELD_STROKE_COLOR, 1);
    //   g.drawRect(text.x, text.y, text.width, text.height);
    // }
  }
}
